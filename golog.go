// Copyright 2022 Jimmy Fj√§llid. All rights reserved
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.

// Package golog serves as a wrapper around the default log
// package to implement logging levels (Critical, Error,
// Warning, Notice, Info, Debug). Where a configured level of
// Error would only print messages of type Error and Critical,
// while a level of Debug would print all log messages.

// The package defines a type MyLogger, with methods for
// formatting output, same as the log package, and it also has
// a predefined 'standard' logger with associated logging
// functions that can be used without creating a custom logger.
// This standard logger has a predefined loglevel of Notice
// which means that any logs created by Info or Debug functions
// will be discarded.
package golog

import (
	"fmt"
	"io"
	"log"
	"os"
)

// These flags define the available log levels that can be configured. A level
// of LevelWarning means that only messages of level including and above will
// be displayed (Warning, Error, Critical). So to display log messages of level
// Debug, the log level must be set to LevelDebug.
const (
	LevelNone = iota
	LevelCritical
	LevelError
	LevelWarning
	LevelNotice
	LevelInfo
	LevelDebug
)

// These flags define which test to prefix each log entry generated by the
// logger and are copied from the default log package.
const (
	Ldate = 1 << iota
	Ltime
	Lmicroseconds
	Llongfile
	Lshortfile
	LUTC
	Lmsgprefix
	LstdFlags = Ldate | Ltime
)

// These flags define helper values for logging output
var (
	DefaultOutput = os.Stdout
	NoOutput      = io.Discard
	std           = New("", LevelNotice, LstdFlags, DefaultOutput)
)

// A MyLogger represents an active logging object that serves as a wrapper
// around the Logger from the log package. Each logging operation will check
// against the defined loglevel to see if the message should be logged before
// passing it on to the underlying log packets Logger.
type MyLogger struct {
	log   *log.Logger
	level int
	name  string
}

// A map to define packet specific loggers such that a packet
// can check if a custom logger exists and if so use it, and otherwise
// fallback to a default logger.
var customLoggers map[string]*MyLogger = make(map[string]*MyLogger)

// Setup a new logger for a given reference.
// Intended usage is to specify a custom logger for a packet.
func Set(name, displayname string, level, flags int, output io.Writer) {
	if val, ok := customLoggers[name]; ok {
		val.level = level
		val.SetFlags(flags)
		val.SetOutput(output)
        if displayname != "" {
            displayname += " "
        }
        val.SetDisplayName(displayname)
	} else {
		customLoggers[name] = New(displayname, level, flags, output)
	}
}

// Get a custom logger if it exists, otherwise return default logger.
func Get(name string) *MyLogger {
	if val, ok := customLoggers[name]; ok {
		return val
	} else {
		newLogger := New(name, LevelNotice, LstdFlags, DefaultOutput)
		customLoggers[name] = newLogger
		return newLogger
	}
}

// New creates a new MyLogger. The level variable sets the loglevel which should
// be used to filter what is logged. The flags variable is passed directly to
// the underlying log package to set Logger flags. The output variable sets the
// destination to which log data will be written.
func New(name string, level, flags int, output io.Writer) *MyLogger {
	// Hack to avoid extra space when not using a custom name
	if name != "" {
		name += " "
	}
	return &MyLogger{
		log:   log.New(output, "", flags),
		level: level,
		name:  name,
	}
}

func SetFlags(flag int) {
	std.log.SetFlags(flag)
}

func (ml *MyLogger) SetFlags(flag int) {
	ml.log.SetFlags(flag)
}

func SetOutput(w io.Writer) {
	std.log.SetOutput(w)
}

func (ml *MyLogger) SetOutput(w io.Writer) {
	ml.log.SetOutput(w)
}

func SetLogLevel(level int) {
	std.level = level
}

func (ml *MyLogger) SetLogLevel(level int) {
	ml.level = level
}

func (ml *MyLogger) SetDisplayName(name string) {
    ml.name = name
}

func (ml *MyLogger) Debug(v ...interface{}) {
	if ml.level >= LevelDebug {
		ml.log.Output(2, fmt.Sprintf(ml.name+"[Debug] %v", v...))
	}
}

func (ml *MyLogger) Debugln(v ...interface{}) {
	if ml.level >= LevelDebug {
		ml.log.Output(2, fmt.Sprintf(ml.name+"[Debug] %v", v...))
	}
}

func (ml *MyLogger) Debugf(format string, v ...interface{}) {
	if ml.level >= LevelDebug {
		ml.log.Output(2, fmt.Sprintf(ml.name+"[Debug] "+format, v...))
	}
}

func (ml *MyLogger) Info(v ...interface{}) {
	if ml.level >= LevelInfo {
		ml.log.Output(2, fmt.Sprintf(ml.name+"[Info] %v", v...))
	}
}

func (ml *MyLogger) Infoln(v ...interface{}) {
	if ml.level >= LevelInfo {
		ml.log.Output(2, fmt.Sprintf(ml.name+"[Info] %v", v...))
	}
}

func (ml *MyLogger) Infof(format string, v ...interface{}) {
	if ml.level >= LevelInfo {
		ml.log.Output(2, fmt.Sprintf(ml.name+"[Info] "+format, v...))
	}
}

func (ml *MyLogger) Notice(v ...interface{}) {
	if ml.level >= LevelNotice {
		ml.log.Output(2, fmt.Sprintf(ml.name+"[Notice] %v", v...))
	}
}

func (ml *MyLogger) Noticeln(v ...interface{}) {
	if ml.level >= LevelNotice {
		ml.log.Output(2, fmt.Sprintf(ml.name+"[Notice] %v", v...))
	}
}

func (ml *MyLogger) Noticef(format string, v ...interface{}) {
	if ml.level >= LevelNotice {
		ml.log.Output(2, fmt.Sprintf(ml.name+"[Notice] "+format, v...))
	}
}

func (ml *MyLogger) Warning(v ...interface{}) {
	if ml.level >= LevelWarning {
		ml.log.Output(2, fmt.Sprintf(ml.name+"[Warning] %v", v...))
	}
}

func (ml *MyLogger) Warningln(v ...interface{}) {
	if ml.level >= LevelWarning {
		ml.log.Output(2, fmt.Sprintf(ml.name+"[Warning] %v", v...))
	}
}

func (ml *MyLogger) Warningf(format string, v ...interface{}) {
	if ml.level >= LevelWarning {
		ml.log.Output(2, fmt.Sprintf(ml.name+"[Warning] "+format, v...))
	}
}

func (ml *MyLogger) Error(v ...interface{}) {
	if ml.level >= LevelError {
		ml.log.Output(2, fmt.Sprintf(ml.name+"[Error] %v", v...))
	}
}

func (ml *MyLogger) Errorln(v ...interface{}) {
	if ml.level >= LevelError {
		ml.log.Output(2, fmt.Sprintf(ml.name+"[Error] %v", v...))
	}
}

func (ml *MyLogger) Errorf(format string, v ...interface{}) {
	if ml.level >= LevelError {
		ml.log.Output(2, fmt.Sprintf(ml.name+"[Error] "+format, v...))
	}
}

func (ml *MyLogger) Critical(v ...interface{}) {
	if ml.level >= LevelCritical {
		ml.log.Output(2, fmt.Sprintf(ml.name+"[Critical] %v", v...))
	}
}

func (ml *MyLogger) Criticalln(v ...interface{}) {
	if ml.level >= LevelCritical {
		ml.log.Output(2, fmt.Sprintf(ml.name+"[Critical] %v", v...))
	}
}

func (ml *MyLogger) Criticalf(format string, v ...interface{}) {
	if ml.level >= LevelCritical {
		ml.log.Output(2, fmt.Sprintf(ml.name+"[Critical] "+format, v...))
	}
}

func Debug(v ...interface{}) {
	if std.level >= LevelDebug {
		std.log.Output(2, fmt.Sprintf("[Debug] %v", v...))
	}
}

func Debugln(v ...interface{}) {
	if std.level >= LevelDebug {
		std.log.Output(2, fmt.Sprintf("[Debug] %v", v...))
	}
}

func Debugf(format string, v ...interface{}) {
	if std.level >= LevelDebug {
		std.log.Output(2, fmt.Sprintf("[Debug] "+format, v...))
	}
}

func Info(v ...interface{}) {
	if std.level >= LevelInfo {
		std.log.Output(2, fmt.Sprintf("[Info] %v", v...))
	}
}

func Infoln(v ...interface{}) {
	if std.level >= LevelInfo {
		std.log.Output(2, fmt.Sprintf("[Info] %v", v...))
	}
}

func Infof(format string, v ...interface{}) {
	if std.level >= LevelInfo {
		std.log.Output(2, fmt.Sprintf("[Info] "+format, v...))
	}
}

func Notice(v ...interface{}) {
	if std.level >= LevelNotice {
		std.log.Output(2, fmt.Sprintf("[Notice] %v", v...))
	}
}

func Noticeln(v ...interface{}) {
	if std.level >= LevelNotice {
		std.log.Output(2, fmt.Sprintf("[Notice] %v", v...))
	}
}

func Noticef(format string, v ...interface{}) {
	if std.level >= LevelNotice {
		std.log.Output(2, fmt.Sprintf("[Notice] "+format, v...))
	}
}

func Warning(v ...interface{}) {
	if std.level >= LevelWarning {
		std.log.Output(2, fmt.Sprintf("[Warning] %v", v...))
	}
}

func Warningln(v ...interface{}) {
	if std.level >= LevelWarning {
		std.log.Output(2, fmt.Sprintf("[Warning] %v", v...))
	}
}

func Warningf(format string, v ...interface{}) {
	if std.level >= LevelWarning {
		std.log.Output(2, fmt.Sprintf("[Warning] "+format, v...))
	}
}

func Error(v ...interface{}) {
	if std.level >= LevelError {
		std.log.Output(2, fmt.Sprintf("[Error] %v", v...))
	}
}

func Errorln(v ...interface{}) {
	if std.level >= LevelError {
		std.log.Output(2, fmt.Sprintf("[Error] %v", v...))
	}
}

func Errorf(format string, v ...interface{}) {
	if std.level >= LevelError {
		std.log.Output(2, fmt.Sprintf("[Error] "+format, v...))
	}
}

func Critical(v ...interface{}) {
	if std.level >= LevelCritical {
		std.log.Output(2, fmt.Sprintf("[Critical] %v", v...))
	}
}

func Criticalln(v ...interface{}) {
	if std.level >= LevelCritical {
		std.log.Output(2, fmt.Sprintf("[Critical] %v", v...))
	}
}

func Criticalf(format string, v ...interface{}) {
	if std.level >= LevelCritical {
		std.log.Output(2, fmt.Sprintf("[Critical] "+format, v...))
	}
}
